{"version":3,"file":"state-7j8ZF84l.js","sources":["../../node_modules/@tanstack/query-core/build/lib/subscribable.mjs","../../node_modules/@tanstack/query-core/build/lib/utils.mjs","../../node_modules/@tanstack/query-core/build/lib/focusManager.mjs","../../node_modules/@tanstack/query-core/build/lib/onlineManager.mjs","../../node_modules/@tanstack/query-core/build/lib/retryer.mjs","../../node_modules/@tanstack/query-core/build/lib/logger.mjs","../../node_modules/@tanstack/query-core/build/lib/notifyManager.mjs","../../node_modules/@tanstack/query-core/build/lib/removable.mjs","../../node_modules/@tanstack/query-core/build/lib/query.mjs","../../node_modules/@tanstack/query-core/build/lib/queryCache.mjs","../../node_modules/@tanstack/query-core/build/lib/mutation.mjs","../../node_modules/@tanstack/query-core/build/lib/mutationCache.mjs","../../node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs","../../node_modules/@tanstack/query-core/build/lib/queryClient.mjs","../../node_modules/@tanstack/query-core/build/lib/queryObserver.mjs","../../node_modules/@tanstack/query-core/build/lib/mutationObserver.mjs","../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js","../../node_modules/use-sync-external-store/shim/index.js","../../node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs","../../node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs","../../node_modules/@tanstack/react-query/build/lib/isRestoring.mjs","../../node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.mjs","../../node_modules/@tanstack/react-query/build/lib/utils.mjs","../../node_modules/@tanstack/react-query/build/lib/useBaseQuery.mjs","../../node_modules/@tanstack/react-query/build/lib/suspense.mjs","../../node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs","../../node_modules/@tanstack/react-query/build/lib/useQuery.mjs","../../node_modules/@tanstack/react-query/build/lib/useMutation.mjs","../../node_modules/zustand/esm/vanilla.mjs","../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js","../../node_modules/use-sync-external-store/shim/with-selector.js","../../node_modules/zustand/esm/index.mjs"],"sourcesContent":["class Subscribable {\n  constructor() {\n    this.listeners = new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    const identity = {\n      listener\n    };\n    this.listeners.add(identity);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(identity);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\nexport { Subscribable };\n//# sourceMappingURL=subscribable.mjs.map\n","// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b, depth = 0) {\n  if (a === b) {\n    return a;\n  }\n\n  if (depth > 500) return b;\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key], depth + 1);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n//# sourceMappingURL=utils.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    const changed = this.focused !== focused;\n\n    if (changed) {\n      this.focused = focused;\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nexport { FocusManager, focusManager };\n//# sourceMappingURL=focusManager.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nconst onlineEvents = ['online', 'offline'];\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        onlineEvents.forEach(event => {\n          window.addEventListener(event, listener, false);\n        });\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach(event => {\n            window.removeEventListener(event, listener);\n          });\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    const changed = this.online !== online;\n\n    if (changed) {\n      this.online = online;\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nexport { OnlineManager, onlineManager };\n//# sourceMappingURL=onlineManager.mjs.map\n","import { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n\n        if (canContinue) {\n          continueResolve(value);\n        }\n\n        return canContinue;\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn == null ? void 0 : continueFn();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n//# sourceMappingURL=retryer.mjs.map\n","const defaultLogger = console;\n\nexport { defaultLogger };\n//# sourceMappingURL=logger.mjs.map\n","import { scheduleMicrotask } from './utils.mjs';\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nexport { createNotifyManager, notifyManager };\n//# sourceMappingURL=notifyManager.mjs.map\n","import { isValidTimeout, isServer } from './utils.mjs';\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\nexport { Removable };\n//# sourceMappingURL=removable.mjs.map\n","import { replaceData, noop, timeUntilStale, getAbortController } from './utils.mjs';\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs';\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.scheduleGc();\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\"Missing queryFn for queryKey '\" + this.options.queryHash + \"'\");\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;\n\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + this.queryHash);\n          }\n\n          onError(new Error(this.queryHash + \" data is undefined\"));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);\n        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({\n          type: 'failed',\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState,\n              fetchStatus: 'idle'\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasData = typeof data !== 'undefined';\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\nexport { Query };\n//# sourceMappingURL=query.mjs.map\n","import { hashQueryKeyByOptions, parseFilterArgs, matchQuery } from './utils.mjs';\nimport { Query } from './query.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\nexport { QueryCache };\n//# sourceMappingURL=queryCache.mjs.map\n","import { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Removable } from './removable.mjs';\nimport { createRetryer, canFetch } from './retryer.mjs';\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.defaultOptions = config.defaultOptions;\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    var _this$retryer$continu, _this$retryer;\n\n    return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({\n            type: 'failed',\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context)); // Notify cache callback\n\n      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context)); // Notify cache callback\n\n        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, undefined, error, this.state.variables, this.state.context, this));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\nexport { Mutation, getDefaultState };\n//# sourceMappingURL=mutation.mjs.map\n","import { notifyManager } from './notifyManager.mjs';\nimport { Mutation } from './mutation.mjs';\nimport { matchMutation, noop } from './utils.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    var _this$resuming;\n\n    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {\n      const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n    }).then(() => {\n      this.resuming = undefined;\n    });\n    return this.resuming;\n  }\n\n}\n\nexport { MutationCache };\n//# sourceMappingURL=mutationCache.mjs.map\n","function infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject(\"Missing queryFn for queryKey '\" + context.options.queryHash + \"'\"));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n\n  return;\n}\n\nexport { getNextPageParam, getPreviousPageParam, hasNextPage, hasPreviousPage, infiniteQueryBehavior };\n//# sourceMappingURL=infiniteQueryBehavior.mjs.map\n","import { parseFilterArgs, parseQueryArgs, functionalUpdate, noop, hashQueryKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\nimport { defaultLogger } from './logger.mjs';\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n    this.mountCount = 0;\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\"Passing a custom logger has been deprecated and will be removed in the next major version.\");\n    }\n  }\n\n  mount() {\n    this.mountCount++;\n    if (this.mountCount !== 1) return;\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    this.mountCount--;\n    if (this.mountCount !== 0) return;\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    this.unsubscribeFocus = undefined;\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n    this.unsubscribeOnline = undefined;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  /**\n   * @deprecated This method will accept only queryKey in the next major version.\n   */\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  ensureQueryData(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const cachedData = this.getQueryData(parsedOptions.queryKey);\n    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey,\n  /**\n   * @deprecated This filters will be removed in the next major version.\n   */\n  filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nexport { QueryClient };\n//# sourceMappingURL=queryClient.mjs.map\n","import { shallowEqualObjects, noop, isServer, isValidTimeout, timeUntilStale, replaceData } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { canFetch, isCancelledError } from './retryer.mjs';\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (process.env.NODE_ENV !== 'production' && typeof (options == null ? void 0 : options.isDataEqual) !== 'undefined') {\n      this.client.getLogger().error(\"The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option\");\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    const result = this.createResult(query, options);\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result;\n      this.currentResultOptions = this.options;\n      this.currentResultState = this.currentQuery.state;\n    }\n\n    return result;\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const isLoading = status === 'loading';\n    const isError = status === 'error';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === 'function' ? notifyOnChangeProps() : notifyOnChangeProps;\n\n      if (notifyOnChangePropsValue === 'all' || !notifyOnChangePropsValue && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n} // this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\n\n\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false;\n  } // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n\n\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData;\n  } // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n\n\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  } // basically, just keep previous properties if nothing changed\n\n\n  return false;\n}\n\nexport { QueryObserver };\n//# sourceMappingURL=queryObserver.mjs.map\n","import { getDefaultState } from './mutation.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { shallowEqualObjects } from './utils.mjs';\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    var _this$currentMutation;\n\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n\n    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$currentMutation2;\n\n      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const isLoading = state.status === 'loading';\n    const result = { ...state,\n      isLoading,\n      isPending: isLoading,\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\nexport { MutationObserver };\n//# sourceMappingURL=mutationObserver.mjs.map\n","/**\n * @license React\n * use-sync-external-store-shim.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useState = React.useState,\n  useEffect = React.useEffect,\n  useLayoutEffect = React.useLayoutEffect,\n  useDebugValue = React.useDebugValue;\nfunction useSyncExternalStore$2(subscribe, getSnapshot) {\n  var value = getSnapshot(),\n    _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }),\n    inst = _useState[0].inst,\n    forceUpdate = _useState[1];\n  useLayoutEffect(\n    function () {\n      inst.value = value;\n      inst.getSnapshot = getSnapshot;\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n    },\n    [subscribe, value, getSnapshot]\n  );\n  useEffect(\n    function () {\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      return subscribe(function () {\n        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      });\n    },\n    [subscribe]\n  );\n  useDebugValue(value);\n  return value;\n}\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  inst = inst.value;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(inst, nextValue);\n  } catch (error) {\n    return !0;\n  }\n}\nfunction useSyncExternalStore$1(subscribe, getSnapshot) {\n  return getSnapshot();\n}\nvar shim =\n  \"undefined\" === typeof window ||\n  \"undefined\" === typeof window.document ||\n  \"undefined\" === typeof window.document.createElement\n    ? useSyncExternalStore$1\n    : useSyncExternalStore$2;\nexports.useSyncExternalStore =\n  void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","'use client';\nimport { useSyncExternalStore as useSyncExternalStore$1 } from 'use-sync-external-store/shim/index.js';\n\nconst useSyncExternalStore = useSyncExternalStore$1;\n\nexport { useSyncExternalStore };\n//# sourceMappingURL=useSyncExternalStore.mjs.map\n","'use client';\nimport * as React from 'react';\n\nconst defaultContext = /*#__PURE__*/React.createContext(undefined);\nconst QueryClientSharingContext = /*#__PURE__*/React.createContext(false); // If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\n\nfunction getQueryClientContext(context, contextSharing) {\n  if (context) {\n    return context;\n  }\n\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext;\n    }\n\n    return window.ReactQueryClientContext;\n  }\n\n  return defaultContext;\n}\n\nconst useQueryClient = ({\n  context\n} = {}) => {\n  const queryClient = React.useContext(getQueryClientContext(context, React.useContext(QueryClientSharingContext)));\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one');\n  }\n\n  return queryClient;\n};\nconst QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false\n}) => {\n  React.useEffect(() => {\n    client.mount();\n    return () => {\n      client.unmount();\n    };\n  }, [client]);\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client.getLogger().error(\"The contextSharing option has been deprecated and will be removed in the next major version\");\n  }\n\n  const Context = getQueryClientContext(context, contextSharing);\n  return /*#__PURE__*/React.createElement(QueryClientSharingContext.Provider, {\n    value: !context && contextSharing\n  }, /*#__PURE__*/React.createElement(Context.Provider, {\n    value: client\n  }, children));\n};\n\nexport { QueryClientProvider, defaultContext, useQueryClient };\n//# sourceMappingURL=QueryClientProvider.mjs.map\n","'use client';\nimport * as React from 'react';\n\nconst IsRestoringContext = /*#__PURE__*/React.createContext(false);\nconst useIsRestoring = () => React.useContext(IsRestoringContext);\nconst IsRestoringProvider = IsRestoringContext.Provider;\n\nexport { IsRestoringProvider, useIsRestoring };\n//# sourceMappingURL=isRestoring.mjs.map\n","'use client';\nimport * as React from 'react';\n\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\n\nconst QueryErrorResetBoundaryContext = /*#__PURE__*/React.createContext(createValue()); // HOOK\n\nconst useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext); // COMPONENT\n\nconst QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /*#__PURE__*/React.createElement(QueryErrorResetBoundaryContext.Provider, {\n    value: value\n  }, typeof children === 'function' ? children(value) : children);\n};\n\nexport { QueryErrorResetBoundary, useQueryErrorResetBoundary };\n//# sourceMappingURL=QueryErrorResetBoundary.mjs.map\n","function shouldThrowError(_useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params);\n  }\n\n  return !!_useErrorBoundary;\n}\n\nexport { shouldThrowError };\n//# sourceMappingURL=utils.mjs.map\n","'use client';\nimport * as React from 'react';\nimport { notifyManager } from '@tanstack/query-core';\nimport { useSyncExternalStore } from './useSyncExternalStore.mjs';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary.mjs';\nimport { useQueryClient } from './QueryClientProvider.mjs';\nimport { useIsRestoring } from './isRestoring.mjs';\nimport { ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError } from './errorBoundaryUtils.mjs';\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic } from './suspense.mjs';\n\nfunction useBaseQuery(options, Observer) {\n  const queryClient = useQueryClient({\n    context: options.context\n  });\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  ensureStaleTime(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(() => new Observer(queryClient, defaultedOptions));\n  const result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(React.useCallback(onStoreChange => {\n    const unsubscribe = isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)); // Update result to make sure we did not miss any query updates\n    // between creating the observer and subscribing to it.\n\n    observer.updateResult();\n    return unsubscribe;\n  }, [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  } // Handle error boundary\n\n\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    useErrorBoundary: defaultedOptions.useErrorBoundary,\n    query: observer.getCurrentQuery()\n  })) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\n\nexport { useBaseQuery };\n//# sourceMappingURL=useBaseQuery.mjs.map\n","/**\n * Ensures minimum staleTime and cacheTime values when suspense is enabled.\n * Despite the name, this function guards both staleTime and cacheTime to prevent\n * infinite re-render loops with synchronous queries.\n *\n * @deprecated in v5 - replaced by ensureSuspenseTimers\n */\nconst ensureStaleTime = defaultedOptions => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n\n    if (typeof defaultedOptions.cacheTime === 'number') {\n      defaultedOptions.cacheTime = Math.max(defaultedOptions.cacheTime, 1000);\n    }\n  }\n};\nconst willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nconst shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);\nconst fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({\n  data\n}) => {\n  defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n}).catch(error => {\n  errorResetBoundary.clearReset();\n  defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n});\n\nexport { ensureStaleTime, fetchOptimistic, shouldSuspend, willFetch };\n//# sourceMappingURL=suspense.mjs.map\n","'use client';\nimport * as React from 'react';\nimport { shouldThrowError } from './utils.mjs';\n\nconst ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nconst useClearResetErrorBoundary = errorResetBoundary => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nconst getHasError = ({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);\n};\n\nexport { ensurePreventErrorBoundaryRetry, getHasError, useClearResetErrorBoundary };\n//# sourceMappingURL=errorBoundaryUtils.mjs.map\n","'use client';\nimport { parseQueryArgs, QueryObserver } from '@tanstack/query-core';\nimport { useBaseQuery } from './useBaseQuery.mjs';\n\nfunction useQuery(arg1, arg2, arg3) {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n  return useBaseQuery(parsedOptions, QueryObserver);\n}\n\nexport { useQuery };\n//# sourceMappingURL=useQuery.mjs.map\n","'use client';\nimport * as React from 'react';\nimport { parseMutationArgs, MutationObserver, notifyManager } from '@tanstack/query-core';\nimport { useSyncExternalStore } from './useSyncExternalStore.mjs';\nimport { useQueryClient } from './QueryClientProvider.mjs';\nimport { shouldThrowError } from './utils.mjs';\n\nfunction useMutation(arg1, arg2, arg3) {\n  const options = parseMutationArgs(arg1, arg2, arg3);\n  const queryClient = useQueryClient({\n    context: options.context\n  });\n  const [observer] = React.useState(() => new MutationObserver(queryClient, options));\n  React.useEffect(() => {\n    observer.setOptions(options);\n  }, [observer, options]);\n  const result = useSyncExternalStore(React.useCallback(onStoreChange => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  const mutate = React.useCallback((variables, mutateOptions) => {\n    observer.mutate(variables, mutateOptions).catch(noop);\n  }, [observer]);\n\n  if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {\n    throw result.error;\n  }\n\n  return { ...result,\n    mutate,\n    mutateAsync: result.mutate\n  };\n} // eslint-disable-next-line @typescript-eslint/no-empty-function\n\nfunction noop() {}\n\nexport { useMutation };\n//# sourceMappingURL=useMutation.mjs.map\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\"),\n  shim = require(\"use-sync-external-store/shim\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useSyncExternalStore = shim.useSyncExternalStore,\n  useRef = React.useRef,\n  useEffect = React.useEffect,\n  useMemo = React.useMemo,\n  useDebugValue = React.useDebugValue;\nexports.useSyncExternalStoreWithSelector = function (\n  subscribe,\n  getSnapshot,\n  getServerSnapshot,\n  selector,\n  isEqual\n) {\n  var instRef = useRef(null);\n  if (null === instRef.current) {\n    var inst = { hasValue: !1, value: null };\n    instRef.current = inst;\n  } else inst = instRef.current;\n  instRef = useMemo(\n    function () {\n      function memoizedSelector(nextSnapshot) {\n        if (!hasMemo) {\n          hasMemo = !0;\n          memoizedSnapshot = nextSnapshot;\n          nextSnapshot = selector(nextSnapshot);\n          if (void 0 !== isEqual && inst.hasValue) {\n            var currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSnapshot))\n              return (memoizedSelection = currentSelection);\n          }\n          return (memoizedSelection = nextSnapshot);\n        }\n        currentSelection = memoizedSelection;\n        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;\n        var nextSelection = selector(nextSnapshot);\n        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n          return (memoizedSnapshot = nextSnapshot), currentSelection;\n        memoizedSnapshot = nextSnapshot;\n        return (memoizedSelection = nextSelection);\n      }\n      var hasMemo = !1,\n        memoizedSnapshot,\n        memoizedSelection,\n        maybeGetServerSnapshot =\n          void 0 === getServerSnapshot ? null : getServerSnapshot;\n      return [\n        function () {\n          return memoizedSelector(getSnapshot());\n        },\n        null === maybeGetServerSnapshot\n          ? void 0\n          : function () {\n              return memoizedSelector(maybeGetServerSnapshot());\n            }\n      ];\n    },\n    [getSnapshot, getServerSnapshot, selector, isEqual]\n  );\n  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n  useEffect(\n    function () {\n      inst.hasValue = !0;\n      inst.value = value;\n    },\n    [value]\n  );\n  useDebugValue(value);\n  return value;\n};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport ReactExports from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useDebugValue } = ReactExports;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nlet didWarnAboutEqualityFn = false;\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity, equalityFn) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n    console.warn(\n      \"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\"\n    );\n    didWarnAboutEqualityFn = true;\n  }\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n"],"names":["Subscribable","constructor","this","listeners","Set","subscribe","bind","listener","identity","add","onSubscribe","delete","onUnsubscribe","hasListeners","size","isServer","window","noop","isValidTimeout","value","Infinity","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","mutationKey","hashQueryKey","status","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","depth","array","isPlainArray","aSize","length","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","isDataEqual","structuralSharing","focusManager","super","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","_this$cleanup2","focused","setFocused","forEach","isFocused","document","includes","visibilityState","onlineEvents","onlineManager","onOnline","event","online","setOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","promise","outerResolve","outerReject","shouldPause","onSuccess","reject","onError","pause","continueResolve","canContinue","onPause","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","defaultLogger","console","notifyManager","queue","transactions","notifyFn","batchNotifyFn","schedule","push","flush","originalQueue","batch","batchCalls","args","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","destroy","clearGcTimeout","scheduleGc","cacheTime","gcTimeout","optionalRemove","updateCacheTime","newCacheTime","clearTimeout","Query","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","getDefaultState","meta","remove","setData","newData","dispatch","manual","setState","setStateOptions","_this$retryer","retryer","reset","observer","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","_this$retryer2","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","addObserver","notify","removeObserver","filter","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","AbortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","defineProperty","enumerable","get","signal","context","fetchFn","_context$fetchOptions2","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","onSettled","isFetchingOptimistic","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","Error","action","_action$meta","_action$dataUpdatedAt","reducer","onQueryUpdate","QueryCache","queries","queriesMap","build","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","queryInMap","clear","getAll","findAll","Mutation","mutationId","mutationCache","failureReason","isPaused","variables","_this$retryer$continu","execute","executeMutation","_this$options$retry","mutationFn","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","onMutate","_this$mutationCache$c7","_this$mutationCache$c8","_this$options$onError","_this$options4","_this$mutationCache$c9","_this$mutationCache$c10","_this$options$onSettl2","_this$options5","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","resumePausedMutations","_this$resuming","resuming","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","fetchPage","_context$signal","_context$signal2","aborted","queryFnResult","getNextPageParam","getPreviousPageParam","finalPromise","QueryClient","queryCache","queryDefaults","mutationDefaults","mountCount","mount","unsubscribeFocus","unsubscribeOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","isFetching","isMutating","getQueryData","_this$queryCache$find","ensureQueryData","parsedOptions","cachedData","fetchQuery","getQueriesData","queryKeyOrFilters","getQueryCache","map","setQueryData","updater","input","functionalUpdate","defaultedOptions","setQueriesData","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","all","invalidateQueries","_ref","_filters$refetchType","refetchType","_options$cancelRefetc","throwOnError","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getMutationCache","getDefaultOptions","setDefaultOptions","setQueryDefaults","firstMatchingDefaults","setMutationDefaults","_defaulted","refetchOnReconnect","useErrorBoundary","suspense","QueryObserver","trackedProps","selectError","bindMethods","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","optimisticResult","keepPreviousData","placeholderData","isPlaceholderData","shouldAssignObserverCurrentProperties","currentResult","currentResultOptions","currentResultState","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","_fetchOptions$cancelR","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","_optimisticResults","fetchOnMount","fetchOptionally","isSuccess","select","selectFn","selectResult","isLoading","isError","isInitialLoading","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","typedKey","has","shouldNotifyListeners","retryOnMount","shouldLoadOnMount","refetchOnMount","field","MutationObserver","mutate","_this$currentMutation","currentMutation","_this$currentMutation2","mutateOptions","isPending","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","React","require$$0","objectIs","is","y","useState","useEffect","useLayoutEffect","useDebugValue","checkIfSnapshotChanged","inst","latestGetSnapshot","getSnapshot","nextValue","shim","createElement","_useState","forceUpdate","useSyncExternalStoreShim_production","useSyncExternalStore","shimModule","exports","useSyncExternalStore$1","defaultContext","React.createContext","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","React.useContext","QueryClientProvider","children","React.useEffect","Context","React.createElement","Provider","IsRestoringContext","QueryErrorResetBoundaryContext","isReset","clearReset","createValue","shouldThrowError","_useErrorBoundary","params","useBaseQuery","Observer","isRestoring","errorResetBoundary","ensureStaleTime","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","React.useState","React.useCallback","onStoreChange","unsubscribe","willFetch","shouldSuspend","getHasError","useQuery","useMutation","parseMutationArgs","mutateAsync","createStoreImpl","createState","partial","replace","nextState","previousState","assign","getState","api","getInitialState","__vite_import_meta_env__","warn","require$$1","useRef","useMemo","withSelector_production","useSyncExternalStoreWithSelector","getServerSnapshot","selector","isEqual","instRef","current","hasValue","memoizedSelector","nextSnapshot","hasMemo","memoizedSnapshot","currentSelection","memoizedSelection","nextSelection","maybeGetServerSnapshot","withSelectorModule","ReactExports","useSyncExternalStoreExports","didWarnAboutEqualityFn","arg","createImpl","createStore","useBoundStore","equalityFn","slice","getServerState","useStore","create"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]}